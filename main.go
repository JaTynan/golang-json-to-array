package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
)

func main() {

	// Opening the file
	fileName := "response.json"
	fmt.Printf("\nAttempting to open file named:%v\n", fileName)
	jsonDatafile, err := os.ReadFile(fileName)
	if err != nil {
		fmt.Printf("\nError opening file:%v\n", err)
		return
	}
	fmt.Printf("\nSuccessfully opened file named:%v\n", fileName)
	fmt.Printf("\nUnmarshaling:%v\n", fileName)
	// Unmarshal JSON data into a generic interface
	var data interface{}
	if err := json.Unmarshal([]byte(jsonDatafile), &data); err != nil {
		log.Fatal(err)
	}

	// Convert the data into a map if it's an object or a slice of maps if it's an array of objects

	switch v := data.(type) {
	case map[string]interface{}:
		processJSON("roottable", v)
	case []interface{}:
		for i, item := range v {
			if obj, ok := item.(map[string]interface{}); ok {
				tableName := fmt.Sprintf("roottable_%d", i+1)
				processJSON(tableName, obj)
			} else {
				log.Fatalf("Unexpected JSON structure in array at index %d", i)
			}
		}
	default:
		log.Fatalf("Unexpected JSON structure")

	}
}

// processJSON generates SQL queries for the provided JSON data
func processJSON(tableName string, data map[string]interface{}) {
	// Generate SQL table creation and insert queries
	var createTableQueries, insertQueries []string
	generateSQL(0, tableName, data, &createTableQueries, &insertQueries, 1, 1, 1)

	// Print the generated SQL queries
	for _, query := range createTableQueries {
		fmt.Println(query)
	}
	for _, query := range insertQueries {
		fmt.Println(query)
	}
}

// generateSQL recursively generates CREATE TABLE and INSERT queries
func generateSQL(recursDepth int, tableName string, data map[string]interface{}, createTableQueries *[]string, insertQueries *[]string, parentID int, childID int, grandchildID int) {
	columns := []string{"id INTEGER PRIMARY KEY generated by default as identity"}
	values := []string{}

	recursDepth++
	if recursDepth == 1 {
		schemaName := "unleashed."
		tableName = schemaName + tableName
	} else {
		grandchildID++
		childID++
	}

	if parentID != 0 {
		// Add foreign key reference to the parent table if parentID is provided
		//parentColumn := tableName + "_parent_id"
		parentColumn := tableName + string(parentID)
		columns = append(columns, parentColumn+" INTEGER")
		values = append(values, fmt.Sprintf("%d", parentID))
	}

	for key, value := range data {
		columnName := key
		var valueStr string

		switch v := value.(type) {
		// if we are going to insert into a table we do not want the text added
		// how can we handle that in this big case, in the query builder remove every second value?
		// or never add the value in the first place, more performant?
		case string:
			if v == "" {
				valueStr = "NULL"
			} else {
				valueStr = fmt.Sprintf("'%s'", v)
			}
			columns = append(columns, columnName+" TEXT")
			values = append(values, valueStr)
		case float64:
			valueStr = fmt.Sprintf("%f", v)
			columns = append(columns, columnName+" REAL")
			values = append(values, valueStr)
		case bool:
			valueStr = fmt.Sprintf("%t", v)
			columns = append(columns, columnName+" BOOLEAN")
			values = append(values, valueStr)
		case nil:
			// Handle explicit null values in JSON
			valueStr = "NULL"
			columns = append(columns, columnName+" TEXT")
			values = append(values, valueStr)
		case map[string]interface{}:
			// Create a new table for nested objects
			childTableName := tableName + "_" + columnName
			childID := childID + 1 // Generate a unique ID
			//childForeignKey := tableName + "_id"
			childForeignKey := tableName + "_" + string(childID)
			generateSQL(recursDepth, childTableName, v, createTableQueries, insertQueries, parentID, childID, grandchildID)
			columns = append(columns, childForeignKey+" INTEGER")
			values = append(values, fmt.Sprintf("%d", childID))
		case []interface{}:
			// Handle arrays (assuming each element is a primitive or object)
			for _, item := range v {
				if obj, ok := item.(map[string]interface{}); ok {
					childTableName := tableName + "_" + columnName
					childID := len(*createTableQueries) + 1 // Generate a unique ID
					//childForeignKey := tableName + "_id"
					childForeignKey := tableName + "_" + string(childID)
					generateSQL(recursDepth, childTableName, obj, createTableQueries, insertQueries, parentID, childID, grandchildID)
					columns = append(columns, childForeignKey+" TEXT")
					values = append(values, fmt.Sprintf("%d", childID))
				} else {
					if item == nil || item == "" {
						valueStr = "NULL"
					} else {
						valueStr = fmt.Sprintf("'%v'", item)
					}
					columns = append(columns, columnName+" TEXT")
					//values = append(values, valueStr)
					values = append(values)
				}
			}
		}
	}

	// Generate the CREATE TABLE query
	createTableQuery := fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (%s);", tableName, strings.Join(columns, ", "))
	*createTableQueries = append(*createTableQueries, createTableQuery)

	// Generate the INSERT query
	insertQuery := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s);", tableName, strings.Join(columns, ", "), strings.Join(values, ", "))
	*insertQueries = append(*insertQueries, insertQuery)
}
